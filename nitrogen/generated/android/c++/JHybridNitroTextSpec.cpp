///
/// JHybridNitroTextSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridNitroTextSpec.hpp"

// Forward declaration of `Fragment` to properly resolve imports.
namespace margelo::nitro::nitrotext { struct Fragment; }
// Forward declaration of `FontWeight` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class FontWeight; }
// Forward declaration of `FontStyle` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class FontStyle; }
// Forward declaration of `TextAlign` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class TextAlign; }
// Forward declaration of `TextTransform` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class TextTransform; }
// Forward declaration of `TextDecorationLine` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class TextDecorationLine; }
// Forward declaration of `TextDecorationStyle` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class TextDecorationStyle; }
// Forward declaration of `NitroRenderer` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class NitroRenderer; }
// Forward declaration of `RichTextStyleRule` to properly resolve imports.
namespace margelo::nitro::nitrotext { struct RichTextStyleRule; }
// Forward declaration of `RichTextStyle` to properly resolve imports.
namespace margelo::nitro::nitrotext { struct RichTextStyle; }
// Forward declaration of `EllipsizeMode` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class EllipsizeMode; }
// Forward declaration of `LineBreakStrategyIOS` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class LineBreakStrategyIOS; }
// Forward declaration of `DynamicTypeRamp` to properly resolve imports.
namespace margelo::nitro::nitrotext { enum class DynamicTypeRamp; }
// Forward declaration of `TextLayoutEvent` to properly resolve imports.
namespace margelo::nitro::nitrotext { struct TextLayoutEvent; }
// Forward declaration of `TextLayout` to properly resolve imports.
namespace margelo::nitro::nitrotext { struct TextLayout; }

#include "Fragment.hpp"
#include <vector>
#include <optional>
#include "JFragment.hpp"
#include <string>
#include "FontWeight.hpp"
#include "JFontWeight.hpp"
#include "FontStyle.hpp"
#include "JFontStyle.hpp"
#include "TextAlign.hpp"
#include "JTextAlign.hpp"
#include "TextTransform.hpp"
#include "JTextTransform.hpp"
#include "TextDecorationLine.hpp"
#include "JTextDecorationLine.hpp"
#include "TextDecorationStyle.hpp"
#include "JTextDecorationStyle.hpp"
#include "NitroRenderer.hpp"
#include "JNitroRenderer.hpp"
#include "RichTextStyleRule.hpp"
#include "JRichTextStyleRule.hpp"
#include "RichTextStyle.hpp"
#include "JRichTextStyle.hpp"
#include "EllipsizeMode.hpp"
#include "JEllipsizeMode.hpp"
#include "LineBreakStrategyIOS.hpp"
#include "JLineBreakStrategyIOS.hpp"
#include "DynamicTypeRamp.hpp"
#include "JDynamicTypeRamp.hpp"
#include "TextLayoutEvent.hpp"
#include <functional>
#include "JFunc_void_TextLayoutEvent.hpp"
#include "JTextLayoutEvent.hpp"
#include "TextLayout.hpp"
#include "JTextLayout.hpp"
#include "JFunc_void.hpp"

namespace margelo::nitro::nitrotext {

  jni::local_ref<JHybridNitroTextSpec::jhybriddata> JHybridNitroTextSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridNitroTextSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridNitroTextSpec::initHybrid),
    });
  }

  size_t JHybridNitroTextSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridNitroTextSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  // Properties
  std::optional<std::vector<Fragment>> JHybridNitroTextSpec::getFragments() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JFragment>>()>("getFragments");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<Fragment> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setFragments(const std::optional<std::vector<Fragment>>& fragments) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JFragment>> /* fragments */)>("setFragments");
    method(_javaPart, fragments.has_value() ? [&]() {
      size_t __size = fragments.value().size();
      jni::local_ref<jni::JArrayClass<JFragment>> __array = jni::JArrayClass<JFragment>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = fragments.value()[__i];
        __array->setElement(__i, *JFragment::fromCpp(__element));
      }
      return __array;
    }() : nullptr);
  }
  std::optional<NitroRenderer> JHybridNitroTextSpec::getRenderer() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JNitroRenderer>()>("getRenderer");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setRenderer(std::optional<NitroRenderer> renderer) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JNitroRenderer> /* renderer */)>("setRenderer");
    method(_javaPart, renderer.has_value() ? JNitroRenderer::fromCpp(renderer.value()) : nullptr);
  }
  std::optional<std::vector<RichTextStyleRule>> JHybridNitroTextSpec::getRichTextStyleRules() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JRichTextStyleRule>>()>("getRichTextStyleRules");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<RichTextStyleRule> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setRichTextStyleRules(const std::optional<std::vector<RichTextStyleRule>>& richTextStyleRules) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JRichTextStyleRule>> /* richTextStyleRules */)>("setRichTextStyleRules");
    method(_javaPart, richTextStyleRules.has_value() ? [&]() {
      size_t __size = richTextStyleRules.value().size();
      jni::local_ref<jni::JArrayClass<JRichTextStyleRule>> __array = jni::JArrayClass<JRichTextStyleRule>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = richTextStyleRules.value()[__i];
        __array->setElement(__i, *JRichTextStyleRule::fromCpp(__element));
      }
      return __array;
    }() : nullptr);
  }
  std::optional<bool> JHybridNitroTextSpec::getSelectable() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getSelectable");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridNitroTextSpec::setSelectable(std::optional<bool> selectable) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* selectable */)>("setSelectable");
    method(_javaPart, selectable.has_value() ? jni::JBoolean::valueOf(selectable.value()) : nullptr);
  }
  std::optional<bool> JHybridNitroTextSpec::getAllowFontScaling() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getAllowFontScaling");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridNitroTextSpec::setAllowFontScaling(std::optional<bool> allowFontScaling) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* allowFontScaling */)>("setAllowFontScaling");
    method(_javaPart, allowFontScaling.has_value() ? jni::JBoolean::valueOf(allowFontScaling.value()) : nullptr);
  }
  std::optional<EllipsizeMode> JHybridNitroTextSpec::getEllipsizeMode() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JEllipsizeMode>()>("getEllipsizeMode");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setEllipsizeMode(std::optional<EllipsizeMode> ellipsizeMode) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JEllipsizeMode> /* ellipsizeMode */)>("setEllipsizeMode");
    method(_javaPart, ellipsizeMode.has_value() ? JEllipsizeMode::fromCpp(ellipsizeMode.value()) : nullptr);
  }
  std::optional<double> JHybridNitroTextSpec::getNumberOfLines() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getNumberOfLines");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setNumberOfLines(std::optional<double> numberOfLines) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* numberOfLines */)>("setNumberOfLines");
    method(_javaPart, numberOfLines.has_value() ? jni::JDouble::valueOf(numberOfLines.value()) : nullptr);
  }
  std::optional<LineBreakStrategyIOS> JHybridNitroTextSpec::getLineBreakStrategyIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JLineBreakStrategyIOS>()>("getLineBreakStrategyIOS");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setLineBreakStrategyIOS(std::optional<LineBreakStrategyIOS> lineBreakStrategyIOS) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JLineBreakStrategyIOS> /* lineBreakStrategyIOS */)>("setLineBreakStrategyIOS");
    method(_javaPart, lineBreakStrategyIOS.has_value() ? JLineBreakStrategyIOS::fromCpp(lineBreakStrategyIOS.value()) : nullptr);
  }
  std::optional<DynamicTypeRamp> JHybridNitroTextSpec::getDynamicTypeRamp() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JDynamicTypeRamp>()>("getDynamicTypeRamp");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setDynamicTypeRamp(std::optional<DynamicTypeRamp> dynamicTypeRamp) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JDynamicTypeRamp> /* dynamicTypeRamp */)>("setDynamicTypeRamp");
    method(_javaPart, dynamicTypeRamp.has_value() ? JDynamicTypeRamp::fromCpp(dynamicTypeRamp.value()) : nullptr);
  }
  std::optional<double> JHybridNitroTextSpec::getMaxFontSizeMultiplier() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getMaxFontSizeMultiplier");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setMaxFontSizeMultiplier(std::optional<double> maxFontSizeMultiplier) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* maxFontSizeMultiplier */)>("setMaxFontSizeMultiplier");
    method(_javaPart, maxFontSizeMultiplier.has_value() ? jni::JDouble::valueOf(maxFontSizeMultiplier.value()) : nullptr);
  }
  std::optional<bool> JHybridNitroTextSpec::getAdjustsFontSizeToFit() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getAdjustsFontSizeToFit");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridNitroTextSpec::setAdjustsFontSizeToFit(std::optional<bool> adjustsFontSizeToFit) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* adjustsFontSizeToFit */)>("setAdjustsFontSizeToFit");
    method(_javaPart, adjustsFontSizeToFit.has_value() ? jni::JBoolean::valueOf(adjustsFontSizeToFit.value()) : nullptr);
  }
  std::optional<double> JHybridNitroTextSpec::getMinimumFontScale() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getMinimumFontScale");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setMinimumFontScale(std::optional<double> minimumFontScale) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* minimumFontScale */)>("setMinimumFontScale");
    method(_javaPart, minimumFontScale.has_value() ? jni::JDouble::valueOf(minimumFontScale.value()) : nullptr);
  }
  std::optional<std::function<void(const TextLayoutEvent& /* layout */)>> JHybridNitroTextSpec::getOnTextLayout() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void_TextLayoutEvent::javaobject>()>("getOnTextLayout_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void(const TextLayoutEvent& /* layout */)> {
      if (__result->isInstanceOf(JFunc_void_TextLayoutEvent_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_TextLayoutEvent_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef](TextLayoutEvent layout) -> void {
          return __resultRef->invoke(layout);
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setOnTextLayout(const std::optional<std::function<void(const TextLayoutEvent& /* layout */)>>& onTextLayout) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_TextLayoutEvent::javaobject> /* onTextLayout */)>("setOnTextLayout_cxx");
    method(_javaPart, onTextLayout.has_value() ? JFunc_void_TextLayoutEvent_cxx::fromCpp(onTextLayout.value()) : nullptr);
  }
  std::optional<std::function<void()>> JHybridNitroTextSpec::getOnPress() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>()>("getOnPress_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setOnPress(const std::optional<std::function<void()>>& onPress) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void::javaobject> /* onPress */)>("setOnPress_cxx");
    method(_javaPart, onPress.has_value() ? JFunc_void_cxx::fromCpp(onPress.value()) : nullptr);
  }
  std::optional<std::function<void()>> JHybridNitroTextSpec::getOnPressIn() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>()>("getOnPressIn_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setOnPressIn(const std::optional<std::function<void()>>& onPressIn) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void::javaobject> /* onPressIn */)>("setOnPressIn_cxx");
    method(_javaPart, onPressIn.has_value() ? JFunc_void_cxx::fromCpp(onPressIn.value()) : nullptr);
  }
  std::optional<std::function<void()>> JHybridNitroTextSpec::getOnPressOut() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFunc_void::javaobject>()>("getOnPressOut_cxx");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() -> std::function<void()> {
      if (__result->isInstanceOf(JFunc_void_cxx::javaClassStatic())) [[likely]] {
        auto downcast = jni::static_ref_cast<JFunc_void_cxx::javaobject>(__result);
        return downcast->cthis()->getFunction();
      } else {
        auto __resultRef = jni::make_global(__result);
        return [__resultRef]() -> void {
          return __resultRef->invoke();
        };
      }
    }()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setOnPressOut(const std::optional<std::function<void()>>& onPressOut) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void::javaobject> /* onPressOut */)>("setOnPressOut_cxx");
    method(_javaPart, onPressOut.has_value() ? JFunc_void_cxx::fromCpp(onPressOut.value()) : nullptr);
  }
  std::optional<std::string> JHybridNitroTextSpec::getText() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getText");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setText(const std::optional<std::string>& text) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* text */)>("setText");
    method(_javaPart, text.has_value() ? jni::make_jstring(text.value()) : nullptr);
  }
  std::optional<std::string> JHybridNitroTextSpec::getSelectionColor() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getSelectionColor");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setSelectionColor(const std::optional<std::string>& selectionColor) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* selectionColor */)>("setSelectionColor");
    method(_javaPart, selectionColor.has_value() ? jni::make_jstring(selectionColor.value()) : nullptr);
  }
  std::optional<double> JHybridNitroTextSpec::getFontSize() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getFontSize");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setFontSize(std::optional<double> fontSize) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* fontSize */)>("setFontSize");
    method(_javaPart, fontSize.has_value() ? jni::JDouble::valueOf(fontSize.value()) : nullptr);
  }
  std::optional<FontWeight> JHybridNitroTextSpec::getFontWeight() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFontWeight>()>("getFontWeight");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setFontWeight(std::optional<FontWeight> fontWeight) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFontWeight> /* fontWeight */)>("setFontWeight");
    method(_javaPart, fontWeight.has_value() ? JFontWeight::fromCpp(fontWeight.value()) : nullptr);
  }
  std::optional<std::string> JHybridNitroTextSpec::getFontColor() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getFontColor");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setFontColor(const std::optional<std::string>& fontColor) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* fontColor */)>("setFontColor");
    method(_javaPart, fontColor.has_value() ? jni::make_jstring(fontColor.value()) : nullptr);
  }
  std::optional<std::string> JHybridNitroTextSpec::getFragmentBackgroundColor() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getFragmentBackgroundColor");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setFragmentBackgroundColor(const std::optional<std::string>& fragmentBackgroundColor) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* fragmentBackgroundColor */)>("setFragmentBackgroundColor");
    method(_javaPart, fragmentBackgroundColor.has_value() ? jni::make_jstring(fragmentBackgroundColor.value()) : nullptr);
  }
  std::optional<FontStyle> JHybridNitroTextSpec::getFontStyle() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JFontStyle>()>("getFontStyle");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setFontStyle(std::optional<FontStyle> fontStyle) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFontStyle> /* fontStyle */)>("setFontStyle");
    method(_javaPart, fontStyle.has_value() ? JFontStyle::fromCpp(fontStyle.value()) : nullptr);
  }
  std::optional<std::string> JHybridNitroTextSpec::getFontFamily() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getFontFamily");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setFontFamily(const std::optional<std::string>& fontFamily) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* fontFamily */)>("setFontFamily");
    method(_javaPart, fontFamily.has_value() ? jni::make_jstring(fontFamily.value()) : nullptr);
  }
  std::optional<double> JHybridNitroTextSpec::getLineHeight() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getLineHeight");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setLineHeight(std::optional<double> lineHeight) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* lineHeight */)>("setLineHeight");
    method(_javaPart, lineHeight.has_value() ? jni::JDouble::valueOf(lineHeight.value()) : nullptr);
  }
  std::optional<double> JHybridNitroTextSpec::getLetterSpacing() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getLetterSpacing");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setLetterSpacing(std::optional<double> letterSpacing) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* letterSpacing */)>("setLetterSpacing");
    method(_javaPart, letterSpacing.has_value() ? jni::JDouble::valueOf(letterSpacing.value()) : nullptr);
  }
  std::optional<TextAlign> JHybridNitroTextSpec::getTextAlign() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JTextAlign>()>("getTextAlign");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setTextAlign(std::optional<TextAlign> textAlign) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JTextAlign> /* textAlign */)>("setTextAlign");
    method(_javaPart, textAlign.has_value() ? JTextAlign::fromCpp(textAlign.value()) : nullptr);
  }
  std::optional<TextTransform> JHybridNitroTextSpec::getTextTransform() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JTextTransform>()>("getTextTransform");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setTextTransform(std::optional<TextTransform> textTransform) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JTextTransform> /* textTransform */)>("setTextTransform");
    method(_javaPart, textTransform.has_value() ? JTextTransform::fromCpp(textTransform.value()) : nullptr);
  }
  std::optional<TextDecorationLine> JHybridNitroTextSpec::getTextDecorationLine() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JTextDecorationLine>()>("getTextDecorationLine");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setTextDecorationLine(std::optional<TextDecorationLine> textDecorationLine) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JTextDecorationLine> /* textDecorationLine */)>("setTextDecorationLine");
    method(_javaPart, textDecorationLine.has_value() ? JTextDecorationLine::fromCpp(textDecorationLine.value()) : nullptr);
  }
  std::optional<std::string> JHybridNitroTextSpec::getTextDecorationColor() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getTextDecorationColor");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setTextDecorationColor(const std::optional<std::string>& textDecorationColor) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* textDecorationColor */)>("setTextDecorationColor");
    method(_javaPart, textDecorationColor.has_value() ? jni::make_jstring(textDecorationColor.value()) : nullptr);
  }
  std::optional<TextDecorationStyle> JHybridNitroTextSpec::getTextDecorationStyle() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JTextDecorationStyle>()>("getTextDecorationStyle");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridNitroTextSpec::setTextDecorationStyle(std::optional<TextDecorationStyle> textDecorationStyle) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JTextDecorationStyle> /* textDecorationStyle */)>("setTextDecorationStyle");
    method(_javaPart, textDecorationStyle.has_value() ? JTextDecorationStyle::fromCpp(textDecorationStyle.value()) : nullptr);
  }

  // Methods
  

} // namespace margelo::nitro::nitrotext
